// Behavioral model of MIPS - single cycle implementation, R-types and addi
module reg_file (RR1,RR2,WR,WD,RegWrite,RD1,RD2,clock);
  input [1:0] RR1,RR2,WR;
  input [15:0] WD;
  input RegWrite,clock;
  output [15:0] RD1,RD2;
  reg [15:0] Regs[0:3];
  assign RD1 = Regs[RR1];
  assign RD2 = Regs[RR2];
  initial Regs[0] = 0;
  always @(negedge clock)
    if (RegWrite==1 & WR!=0) 
	    Regs[WR] <= WD;
endmodule

// Computes the sum and carry of two input bits.
module halfadder (S,C,x,y);
    input x,y;
    output S,C;
   
    xor (S,x,y);
    and (C,x,y);
endmodule

// Combines two half-adders to compute sum & carry of 3 input bits.
module full_adder (x,y,z,C,S);
    input x,y,z;
    output S,C;
    wire S1,D1,D2;
   
    halfadder HA1 (S1,D1,x,y),
              HA2 (S,D2,S1,z);
    or g1 (C,D2,D1);
endmodule

// Selects between two inputs (x and y) based on control signal z.
module mux2x1(x,y,z,out);
    input x,y,z;
    output out;
    wire a,b,c;

    not g1(a,z);

    and g2(b,x,a),
        g3(c,y,z);
    
    or  g4(out,c,b);
endmodule

// Selects between four inputs (w, x, y, z) based on control signal.
module mux4x1(w,x,y,z,ctrl,out);
    input w,x,y,z;
    input[1:0] ctrl;
    output out;

    mux2x1 mux1(w,x,ctrl[0],mux1out),
           mux2(y,z,ctrl[0],mux2out),
           mux3(mux1out,mux2out,ctrl[1],out);
endmodule

// 1-bit ALU
module ALU1 (a,b,ainvert,binvert,op,less,carryin,carryout,result);
   input a,b,less,carryin,ainvert,binvert;
   input [1:0] op;
   output carryout,result;
   wire nota, notb, c, d, e, f, sum;

   not na(nota, a),
       nb(notb, b);
   mux2x1 muxa(a, nota, ainvert, c),
          muxb(b, notb, binvert, d);
   and(e, c, d);
   or(f, c, d);
   full_adder fa(c, d, carryin, carryout, sum);
   mux4x1 muxop(e, f, sum, less, op, result);
endmodule

// 1-bit ALU for the most significant bit
module ALUmsb (a,b,ainvert,binvert,op,less,carryin,carryout,result,set);
   input a,b,less,carryin,ainvert,binvert;
   input [1:0] op;
   output carryout,result,set;
   wire nota, notab, c, f, g;
   
   not na(nota, a),
       nb(notb, b);
   mux2x1 muxa(a, nota, ainvert, c),
          muxb(b, notb, binvert, d);
   and(f, c, d);
   or(g, c, d);
   full_adder fa(c, d, carryin, carryout, set);
   mux4x1 muxop(f, g, set, less, op, result);
endmodule

// 16-bit ALU from combining 16 1-bit ALUs.
module alu (op,a,b,ALUout,zero);
  input [3:0] op;
  input [15:0] a,b;
  output [15:0] ALUout;
  output zero;
  ALU1   alu0 (a[0],b[0],op[3],op[2],op[1:0],set, op[2],c1,ALUout[0]);
  ALU1   alu1 (a[1],b[1],op[3],op[2],op[1:0],1'b0,c1,   c2,ALUout[1]);
  ALU1   alu2 (a[2],b[2],op[3],op[2],op[1:0],1'b0,c2,   c3,ALUout[2]);
  ALU1   alu3 (a[3],b[3],op[3],op[2],op[1:0],1'b0,c3,   c4,ALUout[3]);
  ALU1   alu4 (a[4],b[4],op[3],op[2],op[1:0],1'b0,c4,   c5,ALUout[4]);
  ALU1   alu5 (a[5],b[5],op[3],op[2],op[1:0],1'b0,c5,   c6,ALUout[5]);
  ALU1   alu6 (a[6],b[6],op[3],op[2],op[1:0],1'b0,c6,   c7,ALUout[6]);
  ALU1   alu7 (a[7],b[7],op[3],op[2],op[1:0],1'b0,c7,   c8,ALUout[7]);
  ALU1   alu8 (a[8],b[8],op[3],op[2],op[1:0],1'b0,c8,   c9,ALUout[8]);
  ALU1   alu9 (a[9],b[9],op[3],op[2],op[1:0],1'b0,c9,   c10,ALUout[9]);
  ALU1   alu10(a[10],b[10],op[3],op[2],op[1:0],1'b0,c10,c11,ALUout[10]);
  ALU1   alu11(a[11],b[11],op[3],op[2],op[1:0],1'b0,c11,c12,ALUout[11]);
  ALU1   alu12(a[12],b[12],op[3],op[2],op[1:0],1'b0,c12,c13,ALUout[12]);
  ALU1   alu13(a[13],b[13],op[3],op[2],op[1:0],1'b0,c13,c14,ALUout[13]);
  ALU1   alu14(a[14],b[14],op[3],op[2],op[1:0],1'b0,c14,c15,ALUout[14]);
  ALUmsb alu15 (a[15],b[15],op[3],op[2],op[1:0],1'b0,c14,   c15,ALUout[15],set);
  nor nor1(zero, ALUout[0],ALUout[1],ALUout[2],ALUout[3]);
endmodule

// Decodes instruction opcode and generates control signals.
module MainControl (Op,Control); 
  input [3:0] Op;
  output reg [6:0] Control;
// Control bits: RegDst,ALUSrc,RegWrite,ALUctl
  always @(Op) case (Op)
    4'b0000: Control <= 7'b1_0_1_0010; //ADD
    4'b0001: Control <= 7'b1_0_1_0110; //SUB
    4'b0010: Control <= 7'b1_0_1_0000; //AND
    4'b0011: Control <= 7'b1_0_1_0001; //OR
    4'b0100: Control <= 7'b1_0_1_1100; //NOR
    4'b0101: Control <= 7'b1_0_1_1101; //NAND
    4'b0110: Control <= 7'b1_0_1_0111; //SLT
    4'b0111: Control <= 7'b0_1_1_0010; // ADDI
  endcase
endmodule

// Selects between two 2-bit inputs (I0 and I1) based on control signal Sel.
module doublemux2x1 (I0,I1,Sel,Out);
  input [1:0] I0,I1;
  input Sel;
  output [1:0] Out;
  
  not   g1(a,Sel),
        g2(b,a);
        
  and   g3(c,a,I0[0]),
        g4(d,a,I0[1]),
        g7(g,b,I1[0]),
        g8(h,b,I1[1]);
        
  or    g11(Out[0],c,g),
        g12(Out[1],d,h);
endmodule

// Selects between two 16-bit inputs (I0 and I1) based on control signal Sel.
module sexdecuplemux2x1 (I0,I1,Sel,Out);
  input [15:0] I0,I1;
  input Sel;
  output [15:0] Out;
  
  not   g1(a,Sel),
        g2(b,a);
        
  and   g3(c,a,I0[0]),
        g4(d,a,I0[1]),
        g5(e,a,I0[2]),
        g6(f,a,I0[3]),
        g7(g,a,I0[4]),
        g8(h,a,I0[5]),
        g9(i,a,I0[6]),
        g10(j,a,I0[7]),
        g11(k,a,I0[8]),
        g12(l,a,I0[9]),
        g13(m,a,I0[10]),
        g14(n,a,I0[11]),
        g15(o,a,I0[12]),
        g16(p,a,I0[13]),
        g17(q,a,I0[14]),
        g18(r,a,I0[15]),
        g19(s,b,I1[0]),
        g20(t,b,I1[1]),
        g21(u,b,I1[2]),
        g22(v,b,I1[3]),
        g23(w,b,I1[4]),
        g24(x,b,I1[5]),
        g25(y,b,I1[6]),
        g26(z,b,I1[7]),
        g27(A,b,I1[8]),
        g28(B,b,I1[9]),
        g29(C,b,I1[10]),
        g30(D,b,I1[11]),
        g31(E,b,I1[12]),
        g32(F,b,I1[13]),
        g33(G,b,I1[14]),
        g34(H,b,I1[15]);
        
 or     g35(Out[0],c,s),
        g36(Out[1],d,t),
        g37(Out[2],e,u),
        g38(Out[3],f,v),
        g39(Out[4],g,w),
        g40(Out[5],h,x),
        g41(Out[6],i,y),
        g42(Out[7],j,z),
        g43(Out[8],k,A),
        g44(Out[9],l,B),
        g45(Out[10],m,C),
        g46(Out[11],n,D),
        g47(Out[12],o,E),
        g48(Out[13],p,F),
        g49(Out[14],q,G),
        g50(Out[15],r,H);
endmodule

// Implements  single-cycle CPU that fetches instructions, executes them, and updates the PC.
module CPU (clock,PC,ALUOut,IR);
  input clock;
  output [15:0] ALUOut,IR,PC;
  reg[15:0] PC;
  reg[15:0] IMemory[0:1023];
  wire [15:0] IR,NextPC,A,B,ALUOut,RD2,SignExtend;
  wire [3:0] ALUctl;
  wire [1:0] WR; 
// Test Program
  initial begin
    IMemory[0] = 16'b0111_00_01_00001111;  // addi $t1, $0,  15   ($t1=15)
    IMemory[1] = 16'b0111_00_10_00000111;  // addi $t2, $0,  7    ($t2=7)
    IMemory[2] = 16'b0010_01_10_11_000000;  // and  $t3, $t1, $t2  ($t3=7)
    IMemory[3] = 16'b0001_01_11_10_000000;  // sub  $t2, $t1, $t3  ($t2=8)
    IMemory[4] = 16'b0011_10_11_10_000000;  // or   $t2, $t2, $t3  ($t2=15)
    IMemory[5] = 16'b0000_10_11_11_000000;  // add  $t3, $t2, $t3  ($t3=22)
    IMemory[6] = 16'b0100_10_11_01_000000;  // nor  $t1, $t2, $t3  ($t1=-32)
    IMemory[7] = 16'b0110_11_10_01_000000;  // slt  $t1, $t3, $t2  ($t1=0)
    IMemory[8] = 16'b0110_10_11_01_000000;  // slt  $t1, $t2, $t3  ($t1=1)
  end
  initial PC = 0;
  assign IR = IMemory[PC>>1];
  doublemux2x1 muxwr(IR[9:8], IR[7:6], RegDst, WR);
  sexdecuplemux2x1 muxb(RD2, SignExtend, ALUSrc, B);
  assign SignExtend = {{8{IR[7]}},IR[7:0]}; // sign extension unit
  reg_file rf (IR[11:10],IR[9:8],WR,ALUOut,RegWrite,A,RD2,clock);
  alu fetch (4'b0010,PC,16'b10,NextPC,Unused);
  alu ex (ALUctl, A, B, ALUOut, Zero);
  MainControl MainCtr (IR[15:12],{RegDst,ALUSrc,RegWrite,ALUctl}); 
  always @(negedge clock) begin 
    PC <= NextPC;
  end
endmodule

// Test module
module test ();
  reg clock;
  wire signed [15:0] WD,IR,PC;
  CPU test_cpu(clock,PC,WD,IR);
  always #1 clock = ~clock;
  initial begin
    $display ("Clock PC   IR                                 WD");
    $monitor ("%b     %2d   %b  %3d (%b)",clock,PC,IR,WD,WD);
    clock = 1;
    #16 $finish;
  end
endmodule

/* Output
Clock PC   IR                                 WD
1      0   00100000000010010000000000001111   15 (00000000000000000000000000001111)
0      4   00100000000010100000000000000111    7 (00000000000000000000000000000111)
1      4   00100000000010100000000000000111    7 (00000000000000000000000000000111)
0      8   00000001001010100101100000100100    7 (00000000000000000000000000000111)
1      8   00000001001010100101100000100100    7 (00000000000000000000000000000111)
0     12   00000001001010110101000000100010    8 (00000000000000000000000000001000)
1     12   00000001001010110101000000100010    8 (00000000000000000000000000001000)
0     16   00000001010010110101000000100101   15 (00000000000000000000000000001111)
1     16   00000001010010110101000000100101   15 (00000000000000000000000000001111)
0     20   00000001010010110101100000100000   22 (00000000000000000000000000010110)
1     20   00000001010010110101100000100000   22 (00000000000000000000000000010110)
0     24   00000001010010110100100000100111  -32 (11111111111111111111111111100000)
1     24   00000001010010110100100000100111  -32 (11111111111111111111111111100000)
0     28   00000001011010100100100000101010    0 (00000000000000000000000000000000)
1     28   00000001011010100100100000101010    0 (00000000000000000000000000000000)
0     32   00000001010010110100100000101010    1 (00000000000000000000000000000001)
1     32   00000001010010110100100000101010    1 (00000000000000000000000000000001)
*/